[
  {
    "objectID": "notes/cs334/01-Linear-Classification/01-Linear-Classification.html",
    "href": "notes/cs334/01-Linear-Classification/01-Linear-Classification.html",
    "title": "1 Linear Classification",
    "section": "",
    "text": "feature vector: \\(\\va x=\\mqty[x_1&x_2&\\cdots&x_d]^\\top\\in\\R^d\\). \\(\\R^d\\) is called the feature space.\nlabel: \\(y\\in\\qty{-1,+1}\\), binary.\ntraining set of labeled examples: \\[D=\\qty{\\va x^{(i)},y^{(i)}}_{i=1}^N\\]\nclassifier: \\[h:\\R^d\\to\\qty{-1,+1}.\\]\n\nGola: select the best \\(h\\) from a set of possible classifiers \\(\\mathcal{H}\\) that would (the ability to generalization).\nWe will solve this goal by a learning algorithm, typically an optimization problem \\(\\wrt D\\)."
  },
  {
    "objectID": "notes/cs334/01-Linear-Classification/01-Linear-Classification.html#machine-learning-terminology",
    "href": "notes/cs334/01-Linear-Classification/01-Linear-Classification.html#machine-learning-terminology",
    "title": "1 Linear Classification",
    "section": "",
    "text": "feature vector: \\(\\va x=\\mqty[x_1&x_2&\\cdots&x_d]^\\top\\in\\R^d\\). \\(\\R^d\\) is called the feature space.\nlabel: \\(y\\in\\qty{-1,+1}\\), binary.\ntraining set of labeled examples: \\[D=\\qty{\\va x^{(i)},y^{(i)}}_{i=1}^N\\]\nclassifier: \\[h:\\R^d\\to\\qty{-1,+1}.\\]\n\nGola: select the best \\(h\\) from a set of possible classifiers \\(\\mathcal{H}\\) that would (the ability to generalization).\nWe will solve this goal by a learning algorithm, typically an optimization problem \\(\\wrt D\\)."
  },
  {
    "objectID": "notes/cs334/01-Linear-Classification/01-Linear-Classification.html#linear-classifer-through-origin",
    "href": "notes/cs334/01-Linear-Classification/01-Linear-Classification.html#linear-classifer-through-origin",
    "title": "1 Linear Classification",
    "section": "Linear Classifer (Through Origin)",
    "text": "Linear Classifer (Through Origin)\n\n\n\n\n\n\n\nDefinition 1 (Thresholded Linear Mapping from Feature Vectors to Labels) \\[\nh(\\va x; \\va\\theta)=\\begin{cases}+1\\quad\\text{if }\\va\\theta\\cdot\\va x&gt;0,\\\\-1\\quad\\text{if }\\va\\theta\\cdot\\va x&lt;0\\end{cases},\n\\] where \\(\\va\\theta\\in\\R^d\\) is the parameter vector, and \\(\\va\\theta=\\mqty[\\theta_1,\\theta_2,\\dots,\\theta_d]^\\top\\).\nOne can also write it using the \\(\\operatorname{sign}\\) function: \\[\nh(\\va x;\\va\\theta)=\\operatorname{sign}(\\va\\theta\\cdot\\va x)=\\begin{cases}\n+1\\quad\\text{if }\\va\\theta\\cdot\\va x&gt;0,\\\\\n0\\quad\\text{if }\\va\\theta\\cdot\\va x=0,\\\\\n-1\\quad\\text{if }\\va\\theta\\cdot\\va x&lt;0.\n\\end{cases}.\n\\]\n\n\n\n\n\nRecall: dot product: \\[\n\\va\\theta\\cdot\\va x=\\theta_1x_1+\\theta_2x_2+\\cdots+\\theta_dx_d=\\sum_{j=1}^d\\theta_jx_j,\n\\] a linear combination of input features.\nIn \\(h(\\va x;\\va\\theta)\\), different \\(\\va\\theta\\)’s produce (potentially) different labelings for the same \\(\\va x\\).\n\n\nGraphical Representation\n\n\n\n\n\n\nFigure 1: Decision Boundary\n\n\n\n\nHowever, what happens on this \\(90^\\circ\\) line? We call this line the decision boundary, which separates the two classes. Recall: \\[\n\\va\\theta\\cdot\\va x=\\norm{\\va\\theta}\\cdot\\norm{\\va x}\\cdot\\cos 90^\\circ=0.\n\\]\nView the decision boundary as a hyperplane in \\(\\R^d\\).\n\nDoes the length of \\(\\va\\theta\\) matter? No.\nDoes the direction of \\(\\va\\theta\\) matter? Yes."
  },
  {
    "objectID": "notes/cs334/01-Linear-Classification/01-Linear-Classification.html#linear-classifier-with-offset",
    "href": "notes/cs334/01-Linear-Classification/01-Linear-Classification.html#linear-classifier-with-offset",
    "title": "1 Linear Classification",
    "section": "Linear Classifier with Offset",
    "text": "Linear Classifier with Offset\n\n\n\n\n\n\n\nDefinition 2 (Linear Classifier with Offset) \\[\nh(\\va x;\\va\\theta,b)=\\operatorname{sign}(\\va\\theta\\cdot\\va x+b),\n\\] where \\(\\va x\\in\\R^d\\), \\(\\va\\theta\\in\\R^d\\), and \\(b\\in\\R\\). \\(b\\) is called the offset or intercept.\n\n\n\n\n\nGraphical Representation\n\n\n\n\n\n\nFigure 2: Linear Classifier with Offset\n\n\n\n\nNote that the signed distance from \\(\\va\\theta\\cdot\\va x=0\\) to the hyperplane \\(\\va\\theta\\cdot\\va x+b=0\\) is given by: \\[\n\\dfrac{-b}{\\norm{\\va\\theta}}.\n\\]\n\n\nProof. \n\nPick a point on old decision boundary \\(\\va x^{(1)}\\) satisfies \\[\\va\\theta\\cdot\\va x^{(1)}=0.\\]\nPick a point on the new decision boundary \\(\\va x^{(2)}\\) satisfies \\[\\va\\theta\\cdot\\va x^{(2)}+b=0\\implies\\va\\theta\\va x^{(2)}=-b.\\]\nLet \\(\\va v=\\va x^{(2)}-\\va x^{(1)}.\\)\nNow, project \\(\\va v\\) into direction of \\(\\va\\theta\\): \\[\n\\operatorname{proj}_{\\va\\theta}\\va v=\\qty(\\va v\\cdot\\dfrac{\\va\\theta}{\\norm{\\va\\theta}})\\dfrac{\\va\\theta}{\\norm{\\va\\theta}}.\n\\] Note: \\(\\dfrac{\\va\\theta}{\\norm{\\va\\theta}}\\) is the unit vector in the direction of \\(\\va\\theta\\).\nTherefore, the signed sitance is given by: \\[\n\\va v\\cdot\\dfrac{\\va\\theta}{\\norm{\\va\\theta}}=\\dfrac{\\qty(\\va x^{(2)}-\\va x^{(1)})\\cdot\\va\\theta}{\\norm{\\va\\theta}}=\\dfrac{\\va x^{(2)}\\cdot\\va\\theta-\\va x^{(1)}\\cdot\\va\\theta}{\\norm{\\va\\theta}}=\\dfrac{-b}{\\norm{\\va\\theta}}.\n\\]"
  },
  {
    "objectID": "notes/cs334/01-Linear-Classification/01-Linear-Classification.html#training-error",
    "href": "notes/cs334/01-Linear-Classification/01-Linear-Classification.html#training-error",
    "title": "1 Linear Classification",
    "section": "Training Error",
    "text": "Training Error\n\nIntuition: we want \\(\\va\\theta\\) that works well on training data \\(D\\).\n\n\n\n\n\n\n\n\nRemark 1. We’ve restricted the class of possible clasassifiers to linear classifiers, reducing the chance of overfitting.\n\n\n\n\n\n\n\n\n\n\n\nDefinition 3 (Training Error and Learning Algorithms) The training error (\\(\\epsilon\\)) is the fraction of training examples for which the classifier produces wrong labels: \\[\n\\epsilon_N(\\va \\theta)=\\dfrac{1}{N}\\sum_{i=1}^N\\1\\qty{y^{(i)}\\neq h\\qty(\\va x^{(i)};\\va\\theta)},\n\\] where \\(\\1\\{\\cdot\\}\\) returns \\(1\\) if true and \\(0\\) if false.\nAn equivalent form is: \\[\n\\epsilon_N(\\va \\theta)=\\dfrac{1}{N}\\sum_{i=1}^N\\1\\{{\\color{orange}{\\underbrace{y^{(i)}\\qty(\\va\\theta\\cdot\\va x^{(i)})}_{\\substack{y^(i)\\text{ and }\\va\\theta\\cdot\\va x^{(i)}\\\\\\text{ have opposite signs}}}}}{\\color{green}{\\overbrace{\\leq 0}^{\\substack{\\text{points on the decision boundary}\\\\\\text{are considered misclassified}}}}}\\}\n\\]\n\n\n\n\n\nGoal: Find \\(\\displaystyle\\va\\theta^*=\\argmin_{\\va\\theta}\\epsilon_N\\qty(\\va\\theta)\\).\nHow:\n\nIn general, this is not easy to solve (it’s NP-hard).\nFor now, we will consider a special case: linearly separable data.\n\n\n\n\n\n\n\n\n\nDefinition 4 (Linear Separable) Training examples \\(D=\\qty{\\va x^{(i)}, y^{(i)}}_{i=1}^N\\) are linearly separable through the origin if \\(\\exists\\ \\va\\theta\\) such that \\[\ny^{(i)}\\qty(\\va\\theta\\cdot\\va x^{(i)})&gt;0\\quad\\forall\\ i=1,\\dots, N\n\\]\n\n\n\n\n\n\n\n\n\n\n\nRemark 2. This assumption of linear separability is NOT testable.\n\n\n\n\n\nPerceptron Algorithm\n\nThe perceptron algorithm is a mistaken-driven algorithm. It starts with \\(\\va\\theta=\\va 0\\) (the zero vector), and then tries to update \\(\\va\\theta\\) to correct any mistakes.\n\n\n\n\\begin{algorithm} \\caption{Perceptron (Through Origin)} \\begin{algorithmic} \\Procedure{Perceptron}{$D=\\qty{\\va x^{(i)}, y^{(i)}}_{i=1}^N$} \\State $k=0$; $\\va\\theta^{(0)}=\\va 0$ \\While{not all points are correctly classified} \\For{$i=1,\\dots, N$} \\State \\Comment{$\\color{green}\\text{if mistake}$} \\If{$y^{(i)}\\qty(\\va\\theta^{(k)}\\cdot\\va x^{(i)})\\leq 0$} \\State $\\va\\theta^{(k+1)}=\\va\\theta^{(k)}+y^{(i)}\\va x^{(i)}$ \\State $k++$ \\EndIf \\EndFor \\EndWhile \\EndProcedure \\end{algorithmic} \\end{algorithm}\n\n\n\n\n\n\n\n\n\nTheorem 1 (Existence of Perceptron Solution) The perceptron algorithm (Algorithm 1) converges after a finite number of mistkaes if the training examples are linearly separable through the origin.\n\n\n\n\n\nHowever, :\n\nSolution is not unique\nMay need to loop through the dataset more than once, or not use some points at all.\n\n\n\n\n\\begin{algorithm} \\caption{Perceptron (With Offset)} \\begin{algorithmic} \\Procedure{Perceptron}{$D=\\qty{\\va x^{(i)}, y^{(i)}}_{i=1}^N$} \\State $k=0$; $\\va\\theta^{(0)}=\\va 0$; $b^{(0)}=0$ \\While{not all points are correctly classified} \\For{$i=1,\\dots, N$} \\State \\Comment{$\\color{green}\\text{if mistake}$} \\If{$y^{(i)}\\qty(\\va\\theta^{(k)}\\cdot\\va x^{(i)}+b^{(k)})\\leq 0$} \\State $\\va\\theta^{(k+1)}=\\va\\theta^{(k)}+y^{(i)}\\va x^{(i)}$ \\State $b^{(k+1)}=b^{(k)}+y^{(i)}$ \\State $k++$ \\EndIf \\EndFor \\EndWhile \\EndProcedure \\end{algorithmic} \\end{algorithm}\n\n\n\nProof. Produce augmented vecotrs: \\[\\va x'=\\mqty[1, \\va x]^\\top\\quad\\text{and}\\quad\\va\\theta'=\\mqty[b,\\va\\theta]^\\top.\\] Then, we have implicit offset formula: \\[\\va\\theta'\\cdot\\va x'=b+\\va\\theta\\cdot\\va x.\\] Apply Algorithm 1 to \\(\\va x'\\) and \\(\\va\\theta'\\): \\[\n\\begin{aligned}\n\\va\\theta'^{(k+1)}&=\\va\\theta'^{(k)}+y^{(i)}\\va x'^{(i)}\\\\\n\\mqty[b^{(k+1)},\\va\\theta^{(k+1)}]&=\\mqty[b^{(k)},\\va\\theta^{(k)}]+y^{(i)}\\mqty[1,\\va x^{(i)}]\\\\\n\\implies \\va\\theta^{(k+1)}&=\\va\\theta^{(k)}+y^{(i)}\\va x^{(i)}\\\\\nb^{(k+1)}&=b^{(k)}+y^{(i)}.\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "notes/cs377.html",
    "href": "notes/cs377.html",
    "title": "CS 377 Database Systems",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\n1 The Relational Model\n\n\n\n\n\n\nDatabase\n\n\nRelational Model\n\n\n\nThis lecture discusses the relational model, which is the foundation of modern database systems.\n\n\n\n\n\nAug 28, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n2 Relational Algebra\n\n\n\n\n\n\nDatabase\n\n\nRelational Model\n\n\nRelational Algebra\n\n\n\nThis lecture discusses the relational algebra, which is the foundation of modern database systems. Topics include select, project, and join operators.\n\n\n\n\n\nSep 8, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n3 SQL Introduction\n\n\n\n\n\n\nCoding\n\n\nSQL\n\n\nDatabase\n\n\n\nThis note introduces SQL, the Structured Query Language, which is used to interact with databases. We will cover basic queries, the use of *, AS, conditions, and ORDER BY in SQL.\n\n\n\n\n\nSep 10, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n4 SQL Aggregation\n\n\n\n\n\n\nCoding\n\n\nSQL\n\n\nDatabase\n\n\nAggregation\n\n\n\nThis lecture discusses SQL Aggregation, including computing on a column, GROUP BY, and HAVING clauses.\n\n\n\n\n\nSep 14, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n5 SQL Set Operations\n\n\n\n\n\n\nCoding\n\n\nSQL\n\n\nDatabase\n\n\nSet Operations\n\n\n\nThis lecture discusses SQL set operations, including UNION, INTERSECT, and EXCEPT. It also covers the difference between bag and set semantics in SQL.\n\n\n\n\n\nSep 18, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n6 SQL Join\n\n\n\n\n\n\nCoding\n\n\nSQL\n\n\nDatabase\n\n\nJoin\n\n\n\nThis lecture discusses the different types of joins in SQL, including inner, outer, and cross joins. It also covers the dangers of using NATURAL JOIN and the best practices for using joins in SQL.\n\n\n\n\n\nSep 28, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n7 SQL NULL\n\n\n\n\n\n\nCoding\n\n\nSQL\n\n\nDatabase\n\n\nJoin\n\n\nNULL\n\n\n\nThis lecture discusses the concept of NULL values in SQL, including how to represent missing information and inapplicable attributes. It also covers how to check for NULL values and the impact of NULL values on arithmetic expressions, comparison operators, and aggregation.\n\n\n\n\n\nOct 8, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n8 SQL Subqueries\n\n\n\n\n\n\nCoding\n\n\nSQL\n\n\nDatabase\n\n\nSubqueries\n\n\n\nThis lecture discusses subqueries in SQL, including subqueries in a FROM clause, subqueries in a WHERE clause, and the scope of subqueries. It also covers special cases of subqueries, such as when the subquery returns NULL or multiple values.\n\n\n\n\n\nOct 18, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n9 SQL DDL\n\n\n\n\n\n\nCoding\n\n\nSQL\n\n\nDatabase\n\n\nDDL\n\n\n\nThis lecture discusses Database Modification Language in SQL, including Insert, Delete, Update, and Create operations. It also covers SQL Schemas, Types, Keys, and Foreign Keys.\n\n\n\n\n\nOct 28, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n10 JDBC\n\n\n\n\n\n\nCoding\n\n\nSQL\n\n\nDatabase\n\n\nJava\n\n\nJDBC\n\n\n\nThis lecture discusses how to embed SQL in Java using JDBC. It covers the JDBC API, SQL Injection, and Prepared Statements.\n\n\n\n\n\nOct 30, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n11 ER Design\n\n\n\n\n\n\nDatabase\n\n\nDatabase Design\n\n\nER Design\n\n\n\nThis lecture discusses Entity-Relationship (ER) design, which is a technique for designing databases. It covers the ER model, ER diagrams, and the process of converting ER diagrams to relational schemas.\n\n\n\n\n\nNov 10, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n12 Database Design Theory: Normalization\n\n\n\n\n\n\nDatabase\n\n\nDatabase Design\n\n\nDB Design Theory\n\n\nBCNF\n\n\nNormalization\n\n\nFunctional Dependencies\n\n\nClosure Test\n\n\nFD Projection\n\n\n\nThis lecture discusses the concept of normalization in database design theory. The lecture covers functional dependencies, closure test, and FD projection. It finally introduces the concept of BCNF.\n\n\n\n\n\nNov 18, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n13 NOSQL: Not Only SQL\n\n\n\n\n\n\nDatabase\n\n\nNOSQL\n\n\n\nThis lecture introduces the concept of NOSQL databases and their applications.\n\n\n\n\n\nDec 4, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "cv.html",
    "href": "cv.html",
    "title": "CV",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "notes/nonlinearOpt.html",
    "href": "notes/nonlinearOpt.html",
    "title": "Nonlinear Optimization",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "notes/Calc3.html",
    "href": "notes/Calc3.html",
    "title": "Multivariable Calculus/Calculus 3",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "notes/NumericalAnalysis2.html",
    "href": "notes/NumericalAnalysis2.html",
    "title": "PhD-Level Numerical Analysis I",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "notes/ODE.html",
    "href": "notes/ODE.html",
    "title": "Ordinary Differential Equations",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "notes/cs377/05-sql-set-operations/05-SQL-Set-Operations.html",
    "href": "notes/cs377/05-sql-set-operations/05-SQL-Set-Operations.html",
    "title": "5 SQL Set Operations",
    "section": "",
    "text": "A table can have duplicate tuples, unless this would violate an integrity constraint.\nAnd SELECT-FROM-WHERE (SFW) statements leave duplicates in, unless you say not to!\nWhy?\n\nGetting rid of duplicates is expensive!\nWe may want the duplicates because they tell us how many times something occurred.\n\n\n\n\n\nSQL treats tables as “bags” (or “multisets”) rather than sets.\nBags are just like sets, but duplicates are allowed.\n\n\n\n\n\n\n\nTip 1: Example: Bag Semantics\n\n\n\n\n\n\n\\(\\{6, 2, 7, 1, 9\\}\\) is a set and a bag\n\\(\\{6, 2, 7, 1, 9, 1\\}\\) is not a set but a bag\n\n\n\n\n\nLet sets, order doesn’t matter: \\(\\{6, 2, 7, 1, 9, 1\\}=\\{1, 1, 2, 6, 7, 9\\}\\)\nOperations \\(\\cap\\), \\(\\cup\\), and \\(-\\) with bags:\n\nFor \\(\\cap\\), \\(\\cup\\), and \\(-\\) the number of occurrences of a tuple in the result requires some thought.\nSuppose tuple \\(t\\) occurs:\n\n\\(m\\) times in relation \\(R\\), and\n\\(n\\) times in relation \\(S\\)\n\n\n\n\n\n\nOperation\nNumber of Occurrences of \\(t\\) in tuples\n\n\n\n\n\\(R\\cap S\\)\n\\(\\min(m,n)\\)\n\n\n\\(R\\cup S\\)\n\\(m+n\\)\n\n\n\\(R-S\\)\n\\(\\max(m-n,0)\\)\n\n\n\n\n\\(\\cap\\), \\(\\cup\\), and \\(-\\) in SQL:\n\n(&lt;subquery&gt;) UNION (&lt;subquery&gt;)\n(&lt;subquery&gt;) INTERSECT (&lt;subquery&gt;)\n(&lt;subquery&gt;) EXCEPT (&lt;subquery&gt;)\n\nThe parentheses () are mandatory\nThe operands must be queries; you can’t simply use a relation name.\n\n\n\n\n\n\n\nTip 2: Example: Set Operations in SQL\n\n\n\n\n\n(SELECT sid\n FROM Took\n WHERE grade &gt; 95)\n    UNION\n(SELECT sid\n FROM Took\n WHERE grade &lt; 50);\n\n\n\n\nBag vs. Set Semantics: which is used and when\n\nA SELECT-FROM-WHERE statement uses bag semantics by default.\n\nDuplicates are kept in the result\n\nThe set (INTERSECT/UNION/EXCEPT) operations use set semantics by default\n\nDuplicates are eliminated from the result\n\n\nMotivation: Efficiency\n\nWhen doing projection, it is easier not to eliminate duplicate\n\nJust work one tuple at a time\n\nFor intersection or difference, it is most efficient to sort the relations first.\n\nAt that point you may was well eliminate the duplicates anyway\n\n\nHowever, we can control which semantic is used.\n\nWe can force the result of a SFW query to be a set by using SELECT DISTINCT\nWe can force the result of a set operation to be a bag by using ALL.\n\n\n\n\n\n\n\n\nTip 3: Example: Force to Use Set Operations in SQL\n\n\n\n\n\n(SELECT sid\n FROM Took\n WHERE grade &gt; 95)\n    UNION ALL\n(SELECT sid\n FROM Took\n WHERE grade &lt; 50);\n\n\n\n\n\n\n\n\n\nTip 4: Example: Comparison of Set and Bag Semantics\n\n\n\n\n\n\nA single occurrence of a value for x in B wipes out all occurrences of it from A:\n\n(SELECT x FROM A) EXCEPT (SELECT x FROM B)\n\nWith EXCEPT ALL, we match up the value one by one:\n\n(SELECT x FROM A) EXCEPT (SELECT x FROM B)"
  },
  {
    "objectID": "notes/cs377/05-sql-set-operations/05-SQL-Set-Operations.html#duplicates-in-sql",
    "href": "notes/cs377/05-sql-set-operations/05-SQL-Set-Operations.html#duplicates-in-sql",
    "title": "5 SQL Set Operations",
    "section": "",
    "text": "A table can have duplicate tuples, unless this would violate an integrity constraint.\nAnd SELECT-FROM-WHERE (SFW) statements leave duplicates in, unless you say not to!\nWhy?\n\nGetting rid of duplicates is expensive!\nWe may want the duplicates because they tell us how many times something occurred.\n\n\n\n\n\nSQL treats tables as “bags” (or “multisets”) rather than sets.\nBags are just like sets, but duplicates are allowed.\n\n\n\n\n\n\n\nTip 1: Example: Bag Semantics\n\n\n\n\n\n\n\\(\\{6, 2, 7, 1, 9\\}\\) is a set and a bag\n\\(\\{6, 2, 7, 1, 9, 1\\}\\) is not a set but a bag\n\n\n\n\n\nLet sets, order doesn’t matter: \\(\\{6, 2, 7, 1, 9, 1\\}=\\{1, 1, 2, 6, 7, 9\\}\\)\nOperations \\(\\cap\\), \\(\\cup\\), and \\(-\\) with bags:\n\nFor \\(\\cap\\), \\(\\cup\\), and \\(-\\) the number of occurrences of a tuple in the result requires some thought.\nSuppose tuple \\(t\\) occurs:\n\n\\(m\\) times in relation \\(R\\), and\n\\(n\\) times in relation \\(S\\)\n\n\n\n\n\n\nOperation\nNumber of Occurrences of \\(t\\) in tuples\n\n\n\n\n\\(R\\cap S\\)\n\\(\\min(m,n)\\)\n\n\n\\(R\\cup S\\)\n\\(m+n\\)\n\n\n\\(R-S\\)\n\\(\\max(m-n,0)\\)\n\n\n\n\n\\(\\cap\\), \\(\\cup\\), and \\(-\\) in SQL:\n\n(&lt;subquery&gt;) UNION (&lt;subquery&gt;)\n(&lt;subquery&gt;) INTERSECT (&lt;subquery&gt;)\n(&lt;subquery&gt;) EXCEPT (&lt;subquery&gt;)\n\nThe parentheses () are mandatory\nThe operands must be queries; you can’t simply use a relation name.\n\n\n\n\n\n\n\nTip 2: Example: Set Operations in SQL\n\n\n\n\n\n(SELECT sid\n FROM Took\n WHERE grade &gt; 95)\n    UNION\n(SELECT sid\n FROM Took\n WHERE grade &lt; 50);\n\n\n\n\nBag vs. Set Semantics: which is used and when\n\nA SELECT-FROM-WHERE statement uses bag semantics by default.\n\nDuplicates are kept in the result\n\nThe set (INTERSECT/UNION/EXCEPT) operations use set semantics by default\n\nDuplicates are eliminated from the result\n\n\nMotivation: Efficiency\n\nWhen doing projection, it is easier not to eliminate duplicate\n\nJust work one tuple at a time\n\nFor intersection or difference, it is most efficient to sort the relations first.\n\nAt that point you may was well eliminate the duplicates anyway\n\n\nHowever, we can control which semantic is used.\n\nWe can force the result of a SFW query to be a set by using SELECT DISTINCT\nWe can force the result of a set operation to be a bag by using ALL.\n\n\n\n\n\n\n\n\nTip 3: Example: Force to Use Set Operations in SQL\n\n\n\n\n\n(SELECT sid\n FROM Took\n WHERE grade &gt; 95)\n    UNION ALL\n(SELECT sid\n FROM Took\n WHERE grade &lt; 50);\n\n\n\n\n\n\n\n\n\nTip 4: Example: Comparison of Set and Bag Semantics\n\n\n\n\n\n\nA single occurrence of a value for x in B wipes out all occurrences of it from A:\n\n(SELECT x FROM A) EXCEPT (SELECT x FROM B)\n\nWith EXCEPT ALL, we match up the value one by one:\n\n(SELECT x FROM A) EXCEPT (SELECT x FROM B)"
  },
  {
    "objectID": "notes/cs377/05-sql-set-operations/05-SQL-Set-Operations.html#views",
    "href": "notes/cs377/05-sql-set-operations/05-SQL-Set-Operations.html#views",
    "title": "5 SQL Set Operations",
    "section": "Views",
    "text": "Views\n\nThe idea\n\nA view is a relation defined in terms of stored tables (called base tables) and possibly also other views.\nAccess a view like any base table.\nTwo kinds of view:\n\nVirtual: no tuples are stored; view is just a query for constructing the relation when needed.\nMaterialized: actually constructed and stored. Expensive to maintain.\n\nViews are particularly important when you want to give different access rights (i.e. permissions) to different users viewing data in your tables!\n\n\n\n\n\n\n\nTip 5: Example: Application of Views\n\n\n\n\n\nCanvas student page vs. instructor page\n\n\n\n\n\n\n\n\n\nTip 6: Example: Creating a View\n\n\n\n\n\n\nA view for students who earned an 80 or higher in a CSC course:\n\nCREATE VIEW topresults AS\n    SELECT firstname, surname, cnum\n    FROM Student, Took, Offering\n    WHERE\n        Student.sid = Took.sid AND\n        Took.oid = Offering.oid AND\n        grade &gt;= 80 AND dept = 'CSC';\n\n\n\n\n\nUses of Views\n\nBreak down a large query\nProvide another way of looking at the same data, e.g. for one category of user\nWrap commonly used complex queries"
  },
  {
    "objectID": "notes/cs377/07-sql-null/07-SQL-NULL.html",
    "href": "notes/cs377/07-sql-null/07-SQL-NULL.html",
    "title": "7 SQL NULL",
    "section": "",
    "text": "Missing Information:\n\nMissing value.\n\nE.g., we know a student has some email address, but we don’t know what it is.\n\nInapplicable attribute.\n\nE.g., the value of attribute spouse for a person who is single.\n\n\nRepresenting missing information:\n\nOne possibility: use a special value as a placeholder. E.g.,\n\nIf age unknown, use -1.\nIf StNum unknown, use 999999999.\n\nPros and cons?\n\nBetter solution: use a value not in any domain. We call this a null value.\nTuples in SQL relations can have NULL as a value for one or more components.\n\n\nCheck for NULL values\n\nYou can compare an attribute value to NULL with\n\nIS NULL\nIS NOT NULL\n\n\n\n\n\n\n\n\n\nTip 1: Example: Check for NULL values\n\n\n\n\n\nSELECT *\nFROM Course\nWHERE breadth IS NULL;\n\n\n\n\nNote: do not use WHERE breadth = NULL;\n\n\n\n\nAssume \\(x\\) is NULL\nArithmetic expression: Result is always NULL\n\n\n\n\n\n\n\nTip 2: Example: Arithmetic with NULL\n\n\n\n\n\n\\[x+\\texttt{grade}=\\texttt{NULL}\\] \\[x*0=\\texttt{NULL}\\] \\[x-x=\\texttt{NULL}\\]\n\n\n\n\nComparison operators (\\(&gt;\\), \\(&lt;\\), \\(=\\), \\(\\dots\\)): Result is UNKNOWN (neither TRUE nor FALSE)\n\n\n\n\n\n\n\nTip 3: Example: Comparison with NULL\n\n\n\n\n\n\\[x&lt;32 \\quad\\texttt{ --&gt; UNKNOWN}\\]\n\n\n\n\nThis UNKNOWN is a truth-value\nTruth-values in SQL are: TRUE, FALSE, UNKNOWN (a 3-value truth value system!)\n\nLogic with UNKNOWN: \\[\\begin{aligned}\n\\texttt{UNKNOWN} \\lor\\texttt{FALSE}&\\equiv\\texttt{UNKNOWN}\\\\\n\\texttt{UNKNOWN} \\lor\\texttt{TRUE}&\\equiv\\texttt{TRUE}\\\\\n\\texttt{UNKNOWN} \\land\\texttt{FALSE}&\\equiv\\texttt{FALSE}\\\\\n\\texttt{UNKNOWN} \\land\\texttt{TRUE}&\\equiv\\texttt{UNKNOWN}\\\\\n\\neg\\texttt{UNKNOWN}&\\equiv\\texttt{UNKONWN}\n\\end{aligned}\\]\nA tuple is in a query result \\(\\iff\\) the result of the WHERE clause is TRUE.\n\n\n\n\n\n\n“Aggregation ignores NULL.”\n\nNULL never contributes to a sum, average, or count, and can never be the minimum or maximum of a column (unless every value is NULL).\n\nIf ALL values are NULL in a column, then the result of the aggregation is NULL.\nException: COUNT of an empty set is 0. (think of COUNT(columnName) as a function that counts the non-null values in that column.)\n\n\n\n\n\n\n\nTip 4: Example: Aggregation with NULL\n\n\n\n\n\n\nR&S&T are defined as:\n\n R             |      S             |       T\n   x           |          x         |            x\n -----         |        -----       |          -----\n NULL          |        NULL        |\n 1             |                    |\n\nCOUNT()\n\nCOUNT(R.*)=2 and COUNT(R.x)=1\nCOUNT(S.*)=1 and COUNT(S.x)=0\nCOUNT(T.*)=0 and COUNT(T.x)=0\n\nOther aggregates:\n\nMIN(R.x)=1 and MAX(R.x)=1\nMIN(S.x)=NULL and MAX(S.x)=NULL\nMIN(T.x)=NULL and MAX(T.x)=NULL\n\n\n\n\n\n\n\n\n\nNULL is treated differently by the set operators UNION, EXCEPT, and INTERSECT than it is in search conditions.\nWhen comparing rows, set operators treat NULL values as equal to each other.\nIn contrast, when NULL is compared to NULL in a search condition the result is UNKNOWN (not true)."
  },
  {
    "objectID": "notes/cs377/07-sql-null/07-SQL-NULL.html#null-values-in-sql",
    "href": "notes/cs377/07-sql-null/07-SQL-NULL.html#null-values-in-sql",
    "title": "7 SQL NULL",
    "section": "",
    "text": "Missing Information:\n\nMissing value.\n\nE.g., we know a student has some email address, but we don’t know what it is.\n\nInapplicable attribute.\n\nE.g., the value of attribute spouse for a person who is single.\n\n\nRepresenting missing information:\n\nOne possibility: use a special value as a placeholder. E.g.,\n\nIf age unknown, use -1.\nIf StNum unknown, use 999999999.\n\nPros and cons?\n\nBetter solution: use a value not in any domain. We call this a null value.\nTuples in SQL relations can have NULL as a value for one or more components.\n\n\nCheck for NULL values\n\nYou can compare an attribute value to NULL with\n\nIS NULL\nIS NOT NULL\n\n\n\n\n\n\n\n\n\nTip 1: Example: Check for NULL values\n\n\n\n\n\nSELECT *\nFROM Course\nWHERE breadth IS NULL;\n\n\n\n\nNote: do not use WHERE breadth = NULL;\n\n\n\n\nAssume \\(x\\) is NULL\nArithmetic expression: Result is always NULL\n\n\n\n\n\n\n\nTip 2: Example: Arithmetic with NULL\n\n\n\n\n\n\\[x+\\texttt{grade}=\\texttt{NULL}\\] \\[x*0=\\texttt{NULL}\\] \\[x-x=\\texttt{NULL}\\]\n\n\n\n\nComparison operators (\\(&gt;\\), \\(&lt;\\), \\(=\\), \\(\\dots\\)): Result is UNKNOWN (neither TRUE nor FALSE)\n\n\n\n\n\n\n\nTip 3: Example: Comparison with NULL\n\n\n\n\n\n\\[x&lt;32 \\quad\\texttt{ --&gt; UNKNOWN}\\]\n\n\n\n\nThis UNKNOWN is a truth-value\nTruth-values in SQL are: TRUE, FALSE, UNKNOWN (a 3-value truth value system!)\n\nLogic with UNKNOWN: \\[\\begin{aligned}\n\\texttt{UNKNOWN} \\lor\\texttt{FALSE}&\\equiv\\texttt{UNKNOWN}\\\\\n\\texttt{UNKNOWN} \\lor\\texttt{TRUE}&\\equiv\\texttt{TRUE}\\\\\n\\texttt{UNKNOWN} \\land\\texttt{FALSE}&\\equiv\\texttt{FALSE}\\\\\n\\texttt{UNKNOWN} \\land\\texttt{TRUE}&\\equiv\\texttt{UNKNOWN}\\\\\n\\neg\\texttt{UNKNOWN}&\\equiv\\texttt{UNKONWN}\n\\end{aligned}\\]\nA tuple is in a query result \\(\\iff\\) the result of the WHERE clause is TRUE.\n\n\n\n\n\n\n“Aggregation ignores NULL.”\n\nNULL never contributes to a sum, average, or count, and can never be the minimum or maximum of a column (unless every value is NULL).\n\nIf ALL values are NULL in a column, then the result of the aggregation is NULL.\nException: COUNT of an empty set is 0. (think of COUNT(columnName) as a function that counts the non-null values in that column.)\n\n\n\n\n\n\n\nTip 4: Example: Aggregation with NULL\n\n\n\n\n\n\nR&S&T are defined as:\n\n R             |      S             |       T\n   x           |          x         |            x\n -----         |        -----       |          -----\n NULL          |        NULL        |\n 1             |                    |\n\nCOUNT()\n\nCOUNT(R.*)=2 and COUNT(R.x)=1\nCOUNT(S.*)=1 and COUNT(S.x)=0\nCOUNT(T.*)=0 and COUNT(T.x)=0\n\nOther aggregates:\n\nMIN(R.x)=1 and MAX(R.x)=1\nMIN(S.x)=NULL and MAX(S.x)=NULL\nMIN(T.x)=NULL and MAX(T.x)=NULL\n\n\n\n\n\n\n\n\n\nNULL is treated differently by the set operators UNION, EXCEPT, and INTERSECT than it is in search conditions.\nWhen comparing rows, set operators treat NULL values as equal to each other.\nIn contrast, when NULL is compared to NULL in a search condition the result is UNKNOWN (not true)."
  },
  {
    "objectID": "notes/NumericalAnalysis1.html",
    "href": "notes/NumericalAnalysis1.html",
    "title": "Undergraduate-Level Numerical Analysis",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "notes/Proofs.html#proof-practice",
    "href": "notes/Proofs.html#proof-practice",
    "title": "IB Math AA HL Notes",
    "section": "Proof Practice",
    "text": "Proof Practice"
  },
  {
    "objectID": "notes/Calc2.html",
    "href": "notes/Calc2.html",
    "title": "Calculus 2",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "notes/cs334.html",
    "href": "notes/cs334.html",
    "title": "CS 334 Machine Learning",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\n1 Linear Classification\n\n\n\n\n\n\nDatabase\n\n\nRelational Model\n\n\n\nThis lecture discusses the linear classification, a fundamental concept in machine learning.\n\n\n\n\n\nJan 23, 2025\n\n\nJiuru Lyu\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "blogs.html",
    "href": "blogs.html",
    "title": "My Blogs",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\nPolynomial Representation of Arnoldi\n\n\n\nNumerical Analysis\n\n\nIterative Method\n\n\nLinear Algebra\n\n\nArnoldi\n\n\n\nI’m recently learning about the Arnoldi’s method, and the textbook mentioned that the it can be viewed from a polynomial approximation point of view. However, I think the…\n\n\n\nJiuru Lyu\n\n\nDec 10, 2024\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "photo.html",
    "href": "photo.html",
    "title": "Photograph",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "Class Notes",
    "section": "",
    "text": "High School Level Math\n\nIB Math AA HL Notes\n\n\n\nCollege Level Math\n\nMath Fundamentals\n\nCalculus II\nMultivariable Calculus/Advanced Calculus/Calculus III\nLinear Algebra\nMathematical Proofs\n\n\n\nApplied Mathematics\n\nOrdinary Differential Equations\nNonlinear Optimization\nUndergraduate-Level Numerical Analysis\nPhD-Level Numerical Analysis I\n\n\n\nPure Mathematics\n\nReal Analysis\n\n\n\nData Science, Statistics, and Causal Inference\n\nIntroduction to Causal Inference\nGoogle Data Analytics Learning Notes\nMathematical Statistics\nCausal Designs and Inference\nMachine Learning\n\n\n\n\nComputer Science\n\nObject-Oriented Programming & Introduction to Data Structures\nIntroduction to Data Structure and Algorithms\nDatabase Systems\n\n\n\nOther Fields\n\nIntroduction to Sociology\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Jiuru Lyu",
    "section": "",
    "text": "Hi! My name is Jiuru Lyu, and I am a junior at Emory University studying Applied Mathematics. In my leisure time, I enjoy coffee brewing, traveling, photograph, and commercial aviation.\n\n\n Back to top"
  }
]